unit scr;

interface

uses
  Winapi.Windows, Winapi.Messages,Winapi.UxTheme, Winapi.GDIPOBJ, Winapi.GDIPAPI,
  System.SysUtils, System.Classes, System.Math,
  Vcl.Graphics, Vcl.Controls,
  Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, System.Types;

type
  TPoint3D = record
    X, Y, Z: Double;
  end;

  // === (1) Structuri și constante pentru braț robotic
  TRobotJoint = record
   Length: Double;       // lungimea segmentului
    Theta: Double;        // unghiul articulației (în radiani)
  end;

  TForm6 = class(TForm)
    Image1: TImage;
    Timer1: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
  private
    cloudOffset: Integer;
    FTimeAngle: Double;           // Unghiul de mișcare al soarelui
    FStars: TArray<TPointF>;
    FCloudX, FCloudY: Integer;    // poziţia curentă a norului
     // nou: banner pe planul gardului

     // Robotic arm fields
    RobotBase: TPoint3D;            // poziția de bază în lume
    RobotJoints: array[0..3] of TRobotJoint;
    BallTargets: TArray<TPoint3D>;  // coordonate 3D ale mingilor
    NextBallIdx: Integer;           // index-ul mingii curente


    function  ProjectIso(const P: TPoint3D; const R: TRect): TPoint;
    procedure DrawGradientSky(AC: TCanvas; const R: TRect);
    procedure DrawMovingSun(AC: TCanvas; const R: TRect);
    procedure DrawMoon(AC: TCanvas; const R: TRect);
    procedure DrawClouds(AC: TCanvas; const R: TRect; dx: Integer);
    procedure DrawTree(AC: TCanvas; const R: TRect);
    procedure DrawGround(AC: TCanvas; const R: TRect);
    // restul semnăturilor…
    procedure DrawCourt(AC: TCanvas; const R: TRect);
    procedure DrawNet(AC: TCanvas; const R: TRect);
    procedure DrawFence(AC: TCanvas; const R: TRect);
    procedure DrawLightPoles(AC: TCanvas; const R: TRect);
    procedure DrawMountains(AC: TCanvas; const R: TRect);
    procedure DrawUmpireChair(AC: TCanvas; const R: TRect);
    procedure DrawBanner(AC: TCanvas; const R: TRect);
    procedure DrawRoboticArm(AC: TCanvas; const R: TRect);
    procedure DrawBallBasket(AC: TCanvas; const R: TRect);
    procedure DrawTennisBalls(AC: TCanvas; const R: TRect);
    //procedure DrawDetailedTree(AC: TCanvas; const R: TRect);
    //procedure DrawUmbrella(AC: TCanvas; const R: TRect);




  public
  end;

var
  Form6: TForm6;

implementation

{$R *.dfm}

const
  VerticalOffset = 150;
  StarCount      = 200;

  // === (2) Lungimile segmentelor braț robotic (mm, ajustabile)
  JointLengths: array[0..3] of Double = (100.0, 80.0, 60.0, 30.0);

// =================================================
// Utilitare
// =================================================

function Make3D(X, Y, Z: Double): TPoint3D;
begin
  Result.X := X; Result.Y := Y; Result.Z := Z;
end;

function BlendColor(cNight, cDay: TColor; t: Double): TColor;
begin
  Result := RGB(
    Round(GetRValue(cNight) + (GetRValue(cDay) - GetRValue(cNight)) * t),
    Round(GetGValue(cNight) + (GetGValue(cDay) - GetGValue(cNight)) * t),
    Round(GetBValue(cNight) + (GetBValue(cDay) - GetBValue(cNight)) * t)
  );
end;

//------------------------------------
// Functii brat robotic
//------------------------------------

// === (3) Cinematică directă simplificată (FK)
function FK(const J: array of TRobotJoint; const Base: TPoint3D): TPoint3D;
var
  P: TPoint3D;
  i: Integer;
begin
  P := Base;
  for i := 0 to High(J) do
  begin
    P.X := P.X + J[i].Length * Cos(J[i].Theta);
    P.Z := P.Z + J[i].Length * Sin(J[i].Theta);
  end;
  Result := P;
end;

// (Opțional) stub pentru IK – vei implementa metoda preferată
procedure ComputeNextIKTarget;
begin
  // Calculează unghiurile RobotJoints[...] pentru a ajunge la
  // BallTargets[NextBallIdx] folosind CCD sau Jacobian.
end;


// Colectează coordonatele centrelor mingilor din scenă
function GetAllBalls3D: TArray<TPoint3D>;
begin
  // TODO: parcurge desenul terenului și returnează fiecare centru de minge
  Result := [];
end;

// Calculează distanța 3D între două puncte
function Distance3D(const A, B: TPoint3D): Double;
begin
  Result := Sqrt(Sqr(A.X - B.X) + Sqr(A.Y - B.Y) + Sqr(A.Z - B.Z));
end;

// Elimină mingea din lista BallTargets
procedure RemoveBallAt(idx: Integer);
var
  i: Integer;
begin
  for i := idx to High(Form6.BallTargets)-1 do
    Form6.BallTargets[i] := Form6.BallTargets[i+1];
  SetLength(Form6.BallTargets, Length(Form6.BallTargets)-1);
end;




// =================================================
// Proiecție iso
// =================================================

function TForm6.ProjectIso(const P: TPoint3D; const R: TRect): TPoint;
begin
  Result.X := Round((R.Left + R.Right)/2 + (P.X - P.Z));
  Result.Y := Round((R.Bottom - VerticalOffset)
              - (P.Y*2) - (P.X + P.Z)*0.5);
end;



// =================================================
// Desenare cer + stele
// =================================================

procedure TForm6.DrawGradientSky(AC: TCanvas; const R: TRect);
const
  cDayTop   = $FFE6C8;
  cDayBot   = $C88246;
  cNightTop= $501414;
  cNightBot= $140000;
var
  y, h: Integer;
  f, t, bright: Double;
  botC, topC: TColor;
  R1,G1,B1, R2,G2,B2: Integer;
  i, xPix, yPix: Integer;
  col: TColor;
begin
  // --- gradient ---
  h := R.Bottom - R.Top;
  f := (Sin(FTimeAngle) + 1)/2; // 0 = noapte adâncă, 1 = amiază
  botC := BlendColor(cNightBot, cDayBot, f);
  topC := BlendColor(cNightTop, cDayTop, f);
  R1 := GetRValue(botC); G1 := GetGValue(botC); B1 := GetBValue(botC);
  R2 := GetRValue(topC); G2 := GetGValue(topC); B2 := GetBValue(topC);
  for y := R.Top to R.Bottom do
  begin
    t := (y - R.Top)/h;
    AC.Pen.Color := RGB(
      Round(R1 + (R2-R1)*t),
      Round(G1 + (G2-G1)*t),
      Round(B1 + (B2-B1)*t)
    );
    AC.MoveTo(R.Left, y);
    AC.LineTo(R.Right, y);
  end;

  // --- stele ---
  bright := (0.8 - f)/0.8;
  if bright > 0 then
  begin
    AC.Brush.Style := bsSolid;
    AC.Pen.Width   := 0;
    for i := 0 to High(FStars) do
    begin
      if Random < bright then
      begin
        xPix := R.Left + Trunc(FStars[i].X*(R.Right-R.Left));
        yPix := R.Top  + Trunc(FStars[i].Y*(R.Bottom-R.Top));
        col := RGB(
          Round(200*bright + 55),
          Round(200*bright + 55),
          Round(200*bright + 55)
        );
        AC.Brush.Color := col;
        AC.Pen.Color   := col;
        AC.Rectangle(xPix, yPix, xPix+2, yPix+2);
      end;
    end;
  end;
end;

// =================================================
// Desenare soare
// =================================================

procedure TForm6.DrawMovingSun(AC: TCanvas; const R: TRect);
const
  OrbitScaleX  = 1.0;   // păstrează raza orizontală originală
  OrbitScaleY  = 0.5;   // 50% din înălțime → boltă aplatizată
  SunSizeFactor = 1.5;  // 150% din mărimea originală a discului
var
  cx, cy, baseR, px, py: Double;
  sunR, rayLen: Double;
  i: Integer;
  p0, p1: TPoint;
begin
  // Centru ferestră
  cx := (R.Left + R.Right)/2;
  cy := R.Top + (R.Bottom - R.Top)/2;
  baseR := (R.Right - R.Left)/2;

  // Traiectorie aplatizată
  px := cx + Cos(FTimeAngle) * baseR * OrbitScaleX;
  py := cy - Sin(FTimeAngle) * baseR * OrbitScaleY;

  // Discul solar mărit
  sunR := 30 * SunSizeFactor;

  AC.Brush.Color := clYellow;
  AC.Pen.Color   := clYellow;
  AC.Pen.Width   := 2;
  AC.Ellipse(
    Round(px - sunR), Round(py - sunR),
    Round(px + sunR), Round(py + sunR)
  );

  // Raze proporționale
  rayLen := sunR * 0.6;
  for i := 0 to 7 do
  begin
    p0.X := Round(px + sunR * Cos(2*Pi*i/8));
    p0.Y := Round(py + sunR * Sin(2*Pi*i/8));
    p1.X := Round(px + (sunR + rayLen) * Cos(2*Pi*i/8));
    p1.Y := Round(py + (sunR + rayLen) * Sin(2*Pi*i/8));
    AC.MoveTo(p0.X, p0.Y);
    AC.LineTo(p1.X, p1.Y);
  end;
end;


// =================================================
// Desenare pământ
// =================================================

procedure TForm6.DrawGround(AC: TCanvas; const R: TRect);
const
  StripeCount = 12;     // câte benzi de iarbă
  BladeCount  = 200;    // câte firicele de iarbă random
  BladeLength = 20;     // lungime maximă firicele
var
  groundTopY: Integer;
  stripeH: Integer;
  i, bladeX, bladeY: Integer;
  r1, g1, b1, r2, g2, b2: Byte;
  angle: Double;
begin
  // limităm iarba la jumătatea de jos a ecranului
  groundTopY := (R.Top + R.Bottom) div 2;
  stripeH    := (R.Bottom - groundTopY) div StripeCount;

  // două tonuri de verde
  r1 := 100; g1 := 180; b1 := 100;
  r2 := 140; g2 := 200; b2 := 140;

  // 1) Benzi alternative
  for i := 0 to StripeCount - 1 do
  begin
    if Odd(i) then
      AC.Brush.Color := RGB(r1, g1, b1)
    else
      AC.Brush.Color := RGB(r2, g2, b2);

    AC.FillRect(
      Rect(
        R.Left,
        groundTopY + i * stripeH,
        R.Right,
        groundTopY + (i+1) * stripeH
      )
    );
  end;

  // 2) Firicele de iarbă peste benzi
  AC.Pen.Width := 1;
  for i := 1 to BladeCount do
  begin
    bladeX := R.Left + Random(R.Right - R.Left);
    bladeY := groundTopY + Random(R.Bottom - groundTopY);
    angle  := Random * Pi/3 - Pi/6;  // ±30°

    AC.Pen.Color := RGB(120, 200, 120);
    AC.MoveTo(bladeX, bladeY);
    AC.LineTo(
      bladeX + Round(BladeLength * Cos(angle)),
      bladeY - Round(BladeLength * Sin(angle))
    );
  end;
end;



// =====================================
// Desenare teren de tenis
// =====================================

procedure TForm6.DrawCourt(AC: TCanvas; const R: TRect);
const
  FullW        = 300.0;             // lățimea totală teren
  FullD        = 600.0;             // adâncimea totală teren
  SinglesW     = 200.0;             // lățime între liniile de singles
  ServiceOff   = FullD / 4;         // distanța liniei de serviciu față de centru
  BaselineMark = 10.0;              // semn centrul pe linia de bază
var
  Alley: Double;
  ptsOuter, ptsInner: array[0..3] of TPoint;
  P1, P2: TPoint;
  i: Integer;
begin
  Alley := (FullW - SinglesW) / 2;

  // —– exterior: dreptunghiul doubles
  ptsOuter[0] := ProjectIso(Make3D(-FullW/2, 0, -FullD/2), R);
  ptsOuter[1] := ProjectIso(Make3D( FullW/2, 0, -FullD/2), R);
  ptsOuter[2] := ProjectIso(Make3D( FullW/2, 0,  FullD/2), R);
  ptsOuter[3] := ProjectIso(Make3D(-FullW/2, 0,  FullD/2), R);

  AC.Brush.Color := RGB(30,144,255);
  AC.Pen.Color   := clBlack;
  AC.Polygon(ptsOuter);

  // —– bordură doubles
  AC.Pen.Color := clWhite;
  AC.Pen.Width := 2;
  for i := 0 to 3 do
  begin
    AC.MoveTo(ptsOuter[i].X, ptsOuter[i].Y);
    AC.LineTo(ptsOuter[(i+1) mod 4].X, ptsOuter[(i+1) mod 4].Y);
  end;

  // —– bordură singles (sidelines)
  ptsInner[0] := ProjectIso(Make3D(-FullW/2 + Alley, 0, -FullD/2), R);
  ptsInner[1] := ProjectIso(Make3D( FullW/2 - Alley, 0, -FullD/2), R);
  ptsInner[2] := ProjectIso(Make3D( FullW/2 - Alley, 0,  FullD/2), R);
  ptsInner[3] := ProjectIso(Make3D(-FullW/2 + Alley, 0,  FullD/2), R);
  for i := 0 to 3 do
  begin
    AC.MoveTo(ptsInner[i].X, ptsInner[i].Y);
    AC.LineTo(ptsInner[(i+1) mod 4].X, ptsInner[(i+1) mod 4].Y);
  end;

  // —– linia de mijloc (centru sub fileu)
  P1 := ProjectIso(Make3D(0, 0, -FullD/2), R);
  P2 := ProjectIso(Make3D(0, 0,  FullD/2), R);
  AC.MoveTo(P1.X, P1.Y); AC.LineTo(P2.X, P2.Y);

  // —– liniile de serviciu (la ±FullD/4, pe lățimea singles)
  P1 := ProjectIso(Make3D(-SinglesW/2, 0, -ServiceOff), R);
  P2 := ProjectIso(Make3D( SinglesW/2, 0, -ServiceOff), R);
  AC.MoveTo(P1.X, P1.Y); AC.LineTo(P2.X, P2.Y);

  P1 := ProjectIso(Make3D(-SinglesW/2, 0, ServiceOff), R);
  P2 := ProjectIso(Make3D( SinglesW/2, 0, ServiceOff), R);
  AC.MoveTo(P1.X, P1.Y); AC.LineTo(P2.X, P2.Y);

  // —– semnele de centru pe liniile de bază
  // partea din spate (Z = +FullD/2)
  P1 := ProjectIso(Make3D(0, 0,  FullD/2), R);
  P2 := ProjectIso(Make3D(0, 0,  FullD/2 - BaselineMark), R);
  AC.MoveTo(P1.X, P1.Y); AC.LineTo(P2.X, P2.Y);

  // partea din față (Z = -FullD/2)
  P1 := ProjectIso(Make3D(0, 0, -FullD/2), R);
  P2 := ProjectIso(Make3D(0, 0, -FullD/2 + BaselineMark), R);
  AC.MoveTo(P1.X, P1.Y); AC.LineTo(P2.X, P2.Y);
end;


// =====================================
// Desenare fileu
// =====================================

procedure TForm6.DrawNet(AC: TCanvas; const R: TRect);
const
  W    = 300.0;
  H    = 40.0;
  Step = 15.0;
var
  p1, p2: TPoint;
  xPos: Double;
  i: Integer;
begin
  AC.Pen.Width := 2; AC.Pen.Color := clWhite;
  p1 := ProjectIso(Make3D(-W/2, H, 0), R);
  p2 := ProjectIso(Make3D( W/2, H, 0), R);
  AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
  p1 := ProjectIso(Make3D(-W/2, 0, 0), R);
  p2 := ProjectIso(Make3D( W/2, 0, 0), R);
  AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);

  AC.Pen.Width := 1;
  xPos := -W/2;
  while xPos <= W/2 do
  begin
    p1 := ProjectIso(Make3D(xPos, 0, 0), R);
    p2 := ProjectIso(Make3D(xPos, H, 0), R);
    AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
    xPos := xPos + Step;
  end;

  for i := 0 to Round(H) do
  begin
    p1 := ProjectIso(Make3D(-W/2, i, 0), R);
    p2 := ProjectIso(Make3D( W/2, i, 0), R);
    AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
  end;

  AC.Pen.Width := 3; AC.Pen.Color := clBlack;
  p1 := ProjectIso(Make3D(-W/2+5, 0, 0), R);
  p2 := ProjectIso(Make3D(-W/2+5, H+20, 0), R);
  AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
  p1 := ProjectIso(Make3D( W/2-5, 0, 0), R);
  p2 := ProjectIso(Make3D( W/2-5, H+20, 0), R);
  AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
end;

// =====================================
// Desenare gard
// =====================================

procedure TForm6.DrawFence(AC: TCanvas; const R: TRect);
const
  FenceH    = 200.0;
  FenceStep = 50.0;
var
  corners: array[0..3] of TPoint3D;
  NumV, NumH: Integer;
  i, j: Integer;
  t: Double;
  L3: TPoint3D;
  p1, p2: TPoint;
begin
  corners[0] := Make3D(-300, 0, -300);
  corners[1] := Make3D( 300, 0, -300);
  corners[2] := Make3D( 300, 0,  300);
  corners[3] := Make3D(-300, 0,  300);
  NumV := Round(600 / FenceStep);
  NumH := 4;

  AC.Pen.Width := 1; AC.Pen.Color := clDkGray;
  for i := 0 to 3 do
    for j := 0 to NumV do
    begin
      t := j / NumV;
      L3.X := corners[i].X + (corners[(i+1) mod 4].X - corners[i].X)*t;
      L3.Z := corners[i].Z + (corners[(i+1) mod 4].Z - corners[i].Z)*t;
      L3.Y := 0; p1 := ProjectIso(L3, R);
      L3.Y := FenceH; p2 := ProjectIso(L3, R);
      AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
    end;
  for i := 0 to NumH do
    for j := 0 to 3 do
    begin
      L3 := corners[j]; L3.Y := i * (FenceH / NumH); p1 := ProjectIso(L3, R);
      L3 := corners[(j+1) mod 4]; L3.Y := i * (FenceH / NumH); p2 := ProjectIso(L3, R);
      AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
    end;
end;

// =====================================
// Desenare scaun arbitru
// =====================================

procedure TForm6.DrawUmpireChair(AC: TCanvas; const R: TRect);
const
  SeatW = 40.0; SeatD = 40.0; SeatH = 120.0;
  BackrestH = 40.0; BackrestOffset = 10.0;
  NumFrameLines = 2;
var
  base: TPoint3D;
  feet: array[0..3] of TPoint3D;
  seatPts, backPts: array[0..3] of TPoint;
  i: Integer;
  interpY: Double;
  ptFL, ptFR, ptBL, ptBR: TPoint3D;
  p1, p2: TPoint;
begin
  base := Make3D(170, 0, 0);
  // picioare
  feet[0] := Make3D(base.X - SeatW/2, 0, base.Z - SeatD/2);
  feet[1] := Make3D(base.X - SeatW/2, 0, base.Z + SeatD/2);
  feet[2] := Make3D(base.X + SeatW/2, 0, base.Z + SeatD/2);
  feet[3] := Make3D(base.X + SeatW/2, 0, base.Z - SeatD/2);

  AC.Pen.Width := 3; AC.Pen.Color := clBlack;
  for i := 0 to 3 do
  begin
    p1 := ProjectIso(feet[i], R);
    p2 := ProjectIso(Make3D(feet[i].X, SeatH, feet[i].Z), R);
    AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
  end;

  // șezut
  seatPts[0] := ProjectIso(Make3D(base.X - SeatW/2, SeatH, base.Z - SeatD/2), R);
  seatPts[1] := ProjectIso(Make3D(base.X - SeatW/2, SeatH, base.Z + SeatD/2), R);
  seatPts[2] := ProjectIso(Make3D(base.X + SeatW/2, SeatH, base.Z + SeatD/2), R);
  seatPts[3] := ProjectIso(Make3D(base.X + SeatW/2, SeatH, base.Z - SeatD/2), R);
  AC.Brush.Color := clBlue; AC.Polygon(seatPts);

  // spătar
  backPts[0] := ProjectIso(Make3D(base.X + SeatW/2, SeatH, base.Z - SeatD/2), R);
  backPts[1] := ProjectIso(Make3D(base.X + SeatW/2, SeatH, base.Z + SeatD/2), R);
  backPts[2] := ProjectIso(Make3D(base.X + SeatW/2 + BackrestOffset, SeatH + BackrestH, base.Z + SeatD/2), R);
  backPts[3] := ProjectIso(Make3D(base.X + SeatW/2 + BackrestOffset, SeatH + BackrestH, base.Z - SeatD/2), R);
  AC.Brush.Color := clGray; AC.Polygon(backPts);

  // linii orizontale pe cadru
  AC.Pen.Width := 2; AC.Pen.Color := clBlack;
  for i := 1 to NumFrameLines do
  begin
    interpY := (i / (NumFrameLines + 1)) * SeatH;
    ptFL := Make3D(base.X - SeatW/2, interpY, base.Z - SeatD/2);
    ptFR := Make3D(base.X - SeatW/2, interpY, base.Z + SeatD/2);
    ptBL := Make3D(base.X + SeatW/2, interpY, base.Z - SeatD/2);
    ptBR := Make3D(base.X + SeatW/2, interpY, base.Z + SeatD/2);

    p1 := ProjectIso(ptFL, R); p2 := ProjectIso(ptFR, R);
    AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);

    p1 := ProjectIso(ptBL, R); p2 := ProjectIso(ptBR, R);
    AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);

    p1 := ProjectIso(Make3D(base.X - SeatW/2, interpY, base.Z - SeatD/2), R);
    p2 := ProjectIso(Make3D(base.X + SeatW/2, interpY, base.Z - SeatD/2), R);
    AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);

    p1 := ProjectIso(Make3D(base.X - SeatW/2, interpY, base.Z + SeatD/2), R);
    p2 := ProjectIso(Make3D(base.X + SeatW/2, interpY, base.Z + SeatD/2), R);
    AC.MoveTo(p1.X,p1.Y); AC.LineTo(p2.X,p2.Y);
  end;
end;


procedure TForm6.DrawLightPoles(AC: TCanvas; const R: TRect);
const
  FullW       = 300.0;    // jumătate latime teren
  FullD       = 600.0;    // jumătate adancime teren
  OffsetX     = 200.0;    // poziție X = ±(FullW/2 + OffsetX)
  PoleH       = 255.0;    // înălțime stâlp (puțin peste gard)
  PoleThick   = 6;        // grosimea stâlpului (pixeli)
  ArmLen      = 60.0;     // lungime braț orizontal
  LampLen     = 80;       // lungime corp luminos
  TubeH       = 20;       // înălțime corp luminos
  BraceOff    = 50.0;     // distanța de sus pentru suportul oblic
var
  Bases3D     : array[0..3] of TPoint3D;
  i, j        : Integer;
  signX       : Integer;
  B2, T2, A2  : TPoint;
  L, Rct, T, B: Integer;
  BraceStart, BraceEnd: TPoint;
  xPos       : Double;
  // factor de lumină: 0 = zi, 1 = noapte
  nightFactor: Double;
  lampColor  : TColor;
begin
  // Calculăm cât de „noapte” e, pe baza unghiului soarelui
  // Sin(FTimeAngle) = –1 la apus/răsărit de noapte, +1 la amiază
  nightFactor := (1 - (Sin(FTimeAngle))) / 2;
  if nightFactor < 0 then nightFactor := 0;
  if nightFactor > 1 then nightFactor := 1;

  // pozițiile celor 4 stâlpi
  Bases3D[0] := Make3D( FullW/2 + OffsetX, 0, -FullD/4);
  Bases3D[1] := Make3D( FullW/2 + OffsetX, 0,  FullD/4);
  Bases3D[2] := Make3D(-FullW/2 - OffsetX, 0, -FullD/4);
  Bases3D[3] := Make3D(-FullW/2 - OffsetX, 0,  FullD/4);

  AC.Pen.Width := PoleThick;
  AC.Brush.Style := bsClear;

  for i := 0 to 3 do
  begin
    // direcție braț spre interior
    signX := IfThen(Bases3D[i].X > 0, -1, 1);

    // proiectăm baza și vârful stâlpului
    B2 := ProjectIso(Bases3D[i], R);
    T2 := ProjectIso(Make3D(Bases3D[i].X, PoleH, Bases3D[i].Z), R);

    // desenăm stâlpul
    AC.Pen.Color := clBlack;
    AC.MoveTo(B2.X, B2.Y);
    AC.LineTo(T2.X, T2.Y);

    // suport oblic
    BraceStart := ProjectIso(Make3D(Bases3D[i].X, PoleH - BraceOff, Bases3D[i].Z), R);
    BraceEnd   := ProjectIso(Make3D(Bases3D[i].X + signX*ArmLen/2, PoleH, Bases3D[i].Z), R);
    AC.Pen.Width := 2;
    AC.MoveTo(BraceStart.X, BraceStart.Y);
    AC.LineTo(BraceEnd.X,   BraceEnd.Y);

    // brațul orizontal
    A2 := ProjectIso(Make3D(Bases3D[i].X + signX*ArmLen, PoleH, Bases3D[i].Z), R);
    AC.Pen.Width := PoleThick;
    AC.MoveTo(T2.X, T2.Y);
    AC.LineTo(A2.X, A2.Y);

    // conturul corpului luminos
    if signX > 0 then
    begin
      L    := A2.X;
      Rct  := A2.X + LampLen;
    end
    else
    begin
      L    := A2.X - LampLen;
      Rct  := A2.X;
    end;
    T := A2.Y;
    B := A2.Y + TubeH;

    // culoarea becurilor – negre ziua, galbene/noapteFactor noaptea
    lampColor := BlendColor(clBlack, clYellow, nightFactor);

    AC.Brush.Color := lampColor;
    AC.Pen.Color   := clGray;
    AC.Pen.Width   := 1;
    AC.Rectangle(L, T, Rct, B);

    // lămpi individuale (6 becuri)
    for j := 0 to 5 do
    begin
      var cx := L + (LampLen div 6)*j + (LampLen div 12);
      var topY := T + 4;
      var botY := B - 4;
      AC.Brush.Color := lampColor;
      AC.Pen.Color   := lampColor;
      AC.Ellipse(cx-3, topY, cx+3, botY);
    end;

    // restaurăm pen-ul gros pentru următorul stâlp
    AC.Pen.Width := PoleThick;
    AC.Brush.Style := bsClear;
  end;
end;





//------------------------------------
// Munti
//------------------------------------

procedure TForm6.DrawMountains(AC: TCanvas; const R: TRect);
const
  LayerCount  = 4;
  MinPeakW    = 80;
  MaxPeakW    = 160;
  MaxPeakH    = 60;
  Overlap     = 30;
  // procent fix 0.5 => linia orizontului exact la mijlocul ferestrei
  HorizonPct  = 0.5;
var
  layer, i: Integer;
  HorizonY: Integer;
  baseColor, topColor: TColor;
  t: Double;
  x, w, h: Integer;
  pts: array[0..2] of TPoint;
begin
  // 1) stabilim orizontul fix pe 50% din înălțime
  HorizonY := R.Top + Round((R.Bottom - R.Top) * HorizonPct);

  AC.Pen.Style   := psClear;
  AC.Brush.Style := bsSolid;

  // 2) desenăm straturile de munți din fundal spre prim-plan
  for layer := LayerCount - 1 downto 0 do
  begin
    // 2a) culoarea stratului (întunecat în fundal, deschis în prim-plan)
    t         := layer / (LayerCount - 1);
    baseColor := BlendColor(RGB( 80,100,120), RGB(200,200,230), t);
    topColor  := BlendColor(RGB( 40, 60, 80),  RGB(240,240,255), t);

    // 2b) umplem sub silueta munților pentru efect de relief
    AC.Brush.Color := baseColor;
    AC.Rectangle(
      R.Left, HorizonY - layer * 10,
      R.Right, HorizonY + 1
    );

    // 2c) generăm vârfuri neregulate, suprapuse
    x              := R.Left - MaxPeakW;
    AC.Brush.Color := topColor;
    for i := 0 to (R.Width div (MinPeakW - Overlap)) + 2 do
    begin
      w := MinPeakW + Random(MaxPeakW - MinPeakW);
      h := Random(MaxPeakH) + 20;  // vârf minim de 20px

      pts[0] := Point(x,                   HorizonY - layer * 10);
      pts[1] := Point(x + w div 2,         HorizonY - layer * 10 - h);
      pts[2] := Point(x + w,               HorizonY - layer * 10);

      AC.Polygon(pts);
      Inc(x, w - Overlap);
    end;
  end;

  // 3) restaurăm stilurile de pensulă
  AC.Pen.Style   := psSolid;
  AC.Brush.Style := bsClear;
end;

//---------------------------------------
// Luna
//---------------------------------------

procedure TForm6.DrawMoon(AC: TCanvas; const R: TRect);
const
  OrbitScaleX    = 1.0;
  OrbitScaleY    = 0.5;
  MoonSizeFactor = 1.5;   // semilună cu 150% din raza originală
  cNightBot      = $140000;
  cDayBot        = $C88246;
var
  cx, cy, baseR, mx, my: Double;
  moonR: Double;
  offset: Integer;
  f: Double;
  skyColor: TColor;
begin
  cx := (R.Left + R.Right)/2;
  cy := R.Top + (R.Bottom - R.Top)/2;
  baseR := (R.Right - R.Left)/2;

  mx := cx - Cos(FTimeAngle) * baseR * OrbitScaleX;
  my := cy + Sin(FTimeAngle) * baseR * OrbitScaleY;

  // culoarea de fond pentru «mască»
  f := (Sin(FTimeAngle) + 1)/2;
  skyColor := BlendColor(cNightBot, cDayBot, f);

  // discul lunar mărit
  moonR := 25 * MoonSizeFactor;
  AC.Brush.Color := clWhite;
  AC.Pen.Color   := clWhite;
  AC.Ellipse(
    Round(mx - moonR), Round(my - moonR),
    Round(mx + moonR), Round(my + moonR)
  );

  // suprapunere pentru semilună
  offset := Round(moonR * 0.4);
  AC.Brush.Color := skyColor;
  AC.Pen.Color   := skyColor;
  AC.Ellipse(
    Round(mx - moonR + offset), Round(my - moonR),
    Round(mx + moonR + offset), Round(my + moonR)
  );
end;

//------------------------------
// Banner
//------------------------------

procedure TForm6.DrawBanner(AC: TCanvas; const R: TRect);
const
  BannerW = 250.0;  // lățimea bannerului mai mică
  BannerH = 60.0;   // înălțimea bannerului redusă
  BannerY = 50.0;
  BannerZ = 300.0;
var
  p1, p2, p3, p4: TPoint;
  centerPt: TPointF;
  angleDeg: Single;
  GP: TGPGraphics;
  FontFam: TGPFontFamily;
  GPFont: TGPFont;
  Brush: TGPSolidBrush;
  Format: TGPStringFormat;
begin
  // Calculăm colțurile bannerului
  p1 := ProjectIso(Make3D(-BannerW/2, BannerY,  BannerZ), R);
  p2 := ProjectIso(Make3D( BannerW/2, BannerY,  BannerZ), R);
  p3 := ProjectIso(Make3D( BannerW/2, BannerY + BannerH, BannerZ), R);
  p4 := ProjectIso(Make3D(-BannerW/2, BannerY + BannerH, BannerZ), R);

  // Desenăm bannerul
  AC.Brush.Style := bsSolid;
  AC.Brush.Color := RGB(34, 139, 34);
  AC.Pen.Color   := clBlack;
  AC.Pen.Width   := 2;
  AC.Polygon([p1,p2,p3,p4]);

  // Calculăm centrul bannerului și unghiul muchiei de sus
  centerPt.X := (p1.X + p2.X + p3.X + p4.X) * 0.25;
  centerPt.Y := (p1.Y + p2.Y + p3.Y + p4.Y) * 0.25;
  angleDeg := ArcTan2(p2.Y - p1.Y, p2.X - p1.X) * 180 / Pi;

  // Desenăm textul rotit și centrat în banner
  GP := TGPGraphics.Create(AC.Handle);
  try
    GP.SetSmoothingMode(SmoothingModeAntiAlias);
    GP.TranslateTransform(centerPt.X, centerPt.Y);
    GP.RotateTransform(angleDeg);
    GP.TranslateTransform(-centerPt.X, -centerPt.Y);

    FontFam := TGPFontFamily.Create('Arial');
    GPFont  := TGPFont.Create(FontFam, 32, FontStyleBold, UnitPixel); // font mai mare
    Brush   := TGPSolidBrush.Create(MakeColor(255,255,255,255));
    Format  := TGPStringFormat.Create(StringFormatFlagsNoClip);
    Format.SetAlignment(StringAlignmentCenter);
    Format.SetLineAlignment(StringAlignmentCenter);

    // Dimensiunile dreptunghiului text
    var dx := p2.X - p1.X;
    var dy := p2.Y - p1.Y;
    var w := Sqrt(dx*dx + dy*dy);
    var h := Sqrt(Sqr(p4.X - p1.X) + Sqr(p4.Y - p1.Y));
    var textRect := MakeRect(centerPt.X - w/2, centerPt.Y - h/2, w, h);

    GP.DrawString('Stejareii tennis club', -1, GPFont, textRect, Format, Brush);
  finally
    Format.Free;
    Brush.Free;
    GPFont.Free;
    FontFam.Free;
    GP.Free;
  end;
end;

 const
  CrownOffsets: array[0..5] of TPoint = (
    (X: 0;   Y: 0),
    (X: 20;  Y: -10),
    (X: -25; Y: 10),
    (X: 30;  Y: 20),
    (X: -20; Y: -15),
    (X: 10;  Y: -20)
  );



procedure TForm6.DrawRoboticArm(AC: TCanvas; const R: TRect);
var
  WorldOffsetX, WorldOffsetZ: Double;
  baseCenter3D: TPoint3D;
  baseW, baseD, smallW, smallD, smallH: Double;
  big3D: array[0..3] of TPoint3D;
  smlBot3D, smlTop3D: array[0..3] of TPoint3D;
  big2D, bot2D, top2D: array[0..3] of TPoint;
  // Cele 3 fețe vizibile:
  frontFace, leftFace, topFace: array[0..3] of TPoint;
  pts: array[0..3] of TPoint;
  smallX, smallZ: Double;
  i: Integer;
  baseMount: TPoint;

  // Procedură auxiliară pentru desenarea segmentelor tubulare
  procedure DrawTubeSegment(A, B: TPoint; outerTh, innerTh: Integer);
  var
    dx, dy, L, ux, uy: Double;
    poly: array[0..3] of TPoint;
  begin
    dx := B.X - A.X;
    dy := B.Y - A.Y;
    L  := Sqrt(dx*dx + dy*dy);
    if L = 0 then Exit;
    ux := -dy / L;
    uy := dx / L;
    // Exteriorul segmentului
    poly[0] := Point(Round(A.X + ux * (outerTh/2)), Round(A.Y + uy * (outerTh/2)));
    poly[1] := Point(Round(A.X - ux * (outerTh/2)), Round(A.Y - uy * (outerTh/2)));
    poly[2] := Point(Round(B.X - ux * (outerTh/2)), Round(B.Y - uy * (outerTh/2)));
    poly[3] := Point(Round(B.X + ux * (outerTh/2)), Round(B.Y + uy * (outerTh/2)));
    AC.Brush.Color := $00808080;
    AC.Pen.Color := clBlack;
    AC.Polygon(poly);
    // Linie interioară
    AC.Pen.Color := $00C0C0C0;
    AC.MoveTo(Round(A.X + ux * (innerTh/2)), Round(A.Y + uy * (innerTh/2)));
    AC.LineTo(Round(B.X + ux * (innerTh/2)), Round(B.Y + uy * (innerTh/2)));
  end;

begin
  // 1) Parametrii de bază
  WorldOffsetX := 220.0;
  WorldOffsetZ := -150.0;
  baseW := 120;
  baseD := 60;
  smallW := 40;
  smallD := 30;
  smallH := 15;

  // 2) Calculul centrului bazei mari
  baseCenter3D := Make3D(WorldOffsetX, 0, WorldOffsetZ);

  // 3) Calculul colțurilor bazei mari
  for i := 0 to 3 do
    big3D[i] := Make3D(
      baseCenter3D.X + baseW/2 * IfThen(i in [1,2], 1, -1),
      0,
      baseCenter3D.Z + baseD/2 * IfThen(i in [2,3], 1, -1)
    );

  // 4) Calculul colțurilor cubului (paralelipipedului) – fețele de jos și sus
  for i := 0 to 3 do
  begin
    smallX := smallW/2 * IfThen(i in [1,2], 1, -1);
    smallZ := smallD/2 * IfThen(i in [2,3], 1, -1);
    smlBot3D[i] := Make3D(baseCenter3D.X + smallX, smallH,     baseCenter3D.Z + smallZ);
    smlTop3D[i] := Make3D(baseCenter3D.X + smallX, smallH * 2, baseCenter3D.Z + smallZ);
  end;

  // 5) Proiecție izometrică
  for i := 0 to 3 do
  begin
    //big2D[i] := ProjectIso(big3D[i], R);
    bot2D[i] := ProjectIso(smlBot3D[i], R);
    top2D[i] := ProjectIso(smlTop3D[i], R);
  end;

  // 6) Desenarea bazei mari (de exemplu, podeaua sau suportul)
  AC.Brush.Color := $00666666;
  AC.Pen.Color := clBlack;
  AC.Polygon(big2D);

  // 7) Definirea celor 3 fețe vizibile ale cubului:
  // - Fața frontală: colțurile cu valori mai mici ale lui Z și care se află în față
  frontFace[0] := bot2D[0];
  frontFace[1] := bot2D[1];
  frontFace[2] := top2D[1];
  frontFace[3] := top2D[0];

  // - Fața laterală stângă: aceasta corespunde feței aproximativ desenate cu roșu
  leftFace[0] := bot2D[0];
  leftFace[1] := bot2D[3];
  leftFace[2] := top2D[3];
  leftFace[3] := top2D[0];

  // - Fața superioară: întreaga față de sus a cubului
  topFace[0] := top2D[0];
  topFace[1] := top2D[1];
  topFace[2] := top2D[2];
  topFace[3] := top2D[3];

  // 8) Desenarea fețelor în ordinea corectă (de la spate spre față)
  AC.Brush.Color := $00AAAAAA;  // Fața superioară – cea mai îndepărtată
  AC.Polygon(topFace);

  AC.Brush.Color := clRed;  // Fața laterală stângă – evidențiată cu roșu, conform schiței tale
  AC.Polygon(leftFace);

  AC.Brush.Color := $00888888;  // Fața frontală – ultimul strat, care "ascunde" eventualele margini nedorite
  AC.Polygon(frontFace);

  // 9) Desenarea contururilor (doar a marginilor vizibile)
  AC.Pen.Color := clBlack;
  AC.Pen.Width := 1;
  // Conturul feței frontale
  for i := 0 to 3 do
  begin
    AC.MoveTo(frontFace[i].X, frontFace[i].Y);
    AC.LineTo(frontFace[(i+1) mod 4].X, frontFace[(i+1) mod 4].Y);
  end;
  // Conturul feței laterale (roșii)
  for i := 0 to 3 do
  begin
    AC.MoveTo(leftFace[i].X, leftFace[i].Y);
    AC.LineTo(leftFace[(i+1) mod 4].X, leftFace[(i+1) mod 4].Y);
  end;
  // Conturul feței superioare (parțial)
  AC.MoveTo(topFace[0].X, topFace[0].Y);
  AC.LineTo(topFace[1].X, topFace[1].Y);
  AC.LineTo(topFace[2].X, topFace[2].Y);

  // 10) Montajul brațului robotic (restul codului rămâne neschimbat)
  baseMount := ProjectIso(Make3D(baseCenter3D.X, smallH * 2, baseCenter3D.Z), R);
  pts[0] := baseMount;
  pts[1] := Point(baseMount.X + 60,  baseMount.Y - 100);
  pts[2] := Point(baseMount.X - 140, baseMount.Y - 60);
  pts[3] := Point(baseMount.X - 180, baseMount.Y - 20);

  DrawTubeSegment(pts[0], pts[1], 18, 12);
  DrawTubeSegment(pts[1], pts[2], 18, 12);
  DrawTubeSegment(pts[2], pts[3], 18, 12);

  AC.Brush.Color := $00777777;
  AC.Pen.Color := clBlack;
  for i := 0 to 3 do
    AC.Ellipse(pts[i].X - 12, pts[i].Y - 12, pts[i].X + 12, pts[i].Y + 12);

  AC.Brush.Color := $00808080;
  AC.Pen.Color := clBlack;
  AC.RoundRect(pts[3].X - 24, pts[3].Y - 8, pts[3].X - 8, pts[3].Y + 8, 3, 3);
  AC.RoundRect(pts[3].X + 8, pts[3].Y - 8, pts[3].X + 24, pts[3].Y + 8, 3, 3);
  AC.Rectangle(pts[3].X - 8, pts[3].Y - 8, pts[3].X + 8, pts[3].Y + 8);
end;

//------------------------------------
// desenare nori
//-----------------------------------
procedure TForm6.DrawClouds(AC: TCanvas; const R: TRect; dx: Integer);
var
  // Pozițiile de bază ale norilor (relativ la zona R)
  BaseClouds: array[0..2] of TPoint;
  i: Integer;

  // Procedură locală: desenează un singur nor alungit la poziția (X, Y)
  procedure DrawCloud(X, Y: Integer);
  var
    R1, R2, R3, R4: TRect;
  begin
    // Setăm umplerea cu alb și eliminăm conturul (folosind psClear)
    AC.Brush.Style := bsSolid;
    AC.Brush.Color := clWhite;
    AC.Pen.Style := psClear;

    // Prima elipsă (stângul norului) – mai alungată pe orizontală
    R1 := Rect(X - 80, Y - 10, X + 20, Y + 30);
    AC.Ellipse(R1);

    // A doua elipsă (partea centrală) – extinsă și puțin ridicată
    R2 := Rect(X - 40, Y - 20, X + 40, Y + 40);
    AC.Ellipse(R2);

    // A treia elipsă (dreapta norului) – alungită pe orizontală
    R3 := Rect(X + 0, Y - 10, X + 100, Y + 30);
    AC.Ellipse(R3);

    // A patra elipsă (inferioară) – pentru a netezi conturul de jos
    R4 := Rect(X - 20, Y + 10, X + 60, Y + 50);
    AC.Ellipse(R4);
  end;

begin
  // Setăm pozițiile de bază pentru nori, cu spații mai largi
  BaseClouds[0] := Point(R.Left + 70, R.Top + 40);
  BaseClouds[1] := Point(R.Left + 250, R.Top + 50);
  BaseClouds[2] := Point(R.Left + 430, R.Top + 40);

  // Pentru fiecare nor, se adaugă offset-ul dx pentru a simula mișcarea orizontală
  for i := 0 to High(BaseClouds) do
    DrawCloud(BaseClouds[i].X + dx, BaseClouds[i].Y);
end;


const
  // Definiție pentru clDarkForestGreen: o nuanță de verde închis (RGB: 0,80,0)
  clDarkForestGreen: TColor = $00005000;  // formatul TColor este $00BBGGRR
  // Definiție pentru clBlackForestGreen: o nuanță de verde și mai închis (RGB: 0,40,0)
  clBlackForestGreen: TColor = $00002800;

//---------------------------------
// desenare copac
//---------------------------------
procedure TForm6.DrawTree(AC: TCanvas; const R: TRect);
const
  // Culori: trunchiul este maroniu închis, iar frunzișul are trei nuanțe de verde,
  // de la cel mai deschis la bază la cel mai închis la vârf.
  TRUNK_COLOR = $00004000;
  LAYER_COLORS: array[0..2] of TColor = (
    $0040B040,  // verde deschis
    $00309030,  // verde mediu
    $00207020   // verde închis
  );
var
  CenterX, BaseY: Integer;
  i: Integer;
  Points: array[0..2] of TPoint;
  LeftPt, RightPt, TopPt: TPoint;
begin
  // Mutăm arborele în colțul din stânga sus.
  // CenterX este definit ca un offset mic din marginea stângă.
  CenterX := R.Left + 60;
  // BaseY este acum un offset de sus, plasând baza trunchiului mai sus
  // (de exemplu, 250 pixeli distanță de marginea superioară).
  BaseY := R.Top + 800;

  // Desenăm trunchiul – un dreptunghi centrat la CenterX,
  // având o lățime de 30 pixeli și o înălțime extinsă (100 pixeli) pentru un efect mai înalt.
  AC.Brush.Color := TRUNK_COLOR;
  AC.Pen.Color := TRUNK_COLOR;
  AC.Rectangle(CenterX - 15, BaseY - 100, CenterX + 15, BaseY);

  // Setăm grosimea pen-ului pentru conturul frunzișului
  AC.Pen.Width := 2;

  // Desenăm trei straturi de frunziș folosind triunghiuri simple,
  // ajustând valorile pentru a extinde vertical arborele.
  for i := 0 to 2 do
  begin
    AC.Brush.Color := LAYER_COLORS[i];
    case i of
      0: begin
           // Strat inferior: cel mai lat
           LeftPt  := Point(CenterX - 90, BaseY - 100);   // Baza stângă la nivelul superioară al trunchiului
           RightPt := Point(CenterX + 90, BaseY - 100);    // Baza dreaptă
           TopPt   := Point(CenterX, BaseY - 220);         // Vârful acestui strat
         end;
      1: begin
           // Strat mijlociu: puțin mai restrâns
           LeftPt  := Point(CenterX - 75, BaseY - 160);
           RightPt := Point(CenterX + 75, BaseY - 160);
           TopPt   := Point(CenterX, BaseY - 300);
         end;
      2: begin
           // Strat superior: cel mai îngust
           LeftPt  := Point(CenterX - 60, BaseY - 220);
           RightPt := Point(CenterX + 60, BaseY - 220);
           TopPt   := Point(CenterX, BaseY - 360);
         end;
    end;
    Points[0] := LeftPt;
    Points[1] := RightPt;
    Points[2] := TopPt;
    AC.Polygon(Points);
  end;
end;



//-------------------------------------
// Cos de mingi corectat
//-------------------------------------
procedure TForm6.DrawBallBasket(AC: TCanvas; const R: TRect);
const
  BaseRadius = 30.0;    // Raza bazei redusă
  TopRadius = 50.0;     // Raza vârfului redusă
  BasketHeight = 70.0; // Înălțime totală redusă
  BarCount = 20;        // Număr bare verticale
  RingCount = 5;        // Număr inele orizontale redus
  isoScale = 0.866;     // Factor scalare izometrică
var
  BasketCenter: TPoint3D;
  i, j: Integer;
  angle, y, currentRadius: Double;
  start3D: TPoint3D;
  startPoint, centerPoint: TPoint;
begin
  // 1. Poziționare mai departe de brațul robotic
  BasketCenter := Make3D(30, 0, -250); // Coordonate ajustate

  // 2. Inițializare setări
  AC.Pen.Width := 1;
  AC.Brush.Style := bsClear;

  // 3. Structură verticală conică
  AC.Pen.Color := $C0C0C0; // Gri deschis
  for j := 0 to BarCount - 1 do
  begin
    angle := 2 * Pi * j / BarCount;
    for i := 0 to RingCount do
    begin
      y := i * (BasketHeight / RingCount);
      currentRadius := BaseRadius + (TopRadius - BaseRadius) * (y / BasketHeight);

      start3D := Make3D(
        BasketCenter.X + currentRadius * Cos(angle),
        BasketCenter.Y + y,
        BasketCenter.Z + currentRadius * Sin(angle) * isoScale
      );

      startPoint := ProjectIso(start3D, R);
      if i = 0 then
        AC.MoveTo(startPoint.X, startPoint.Y)
      else
        AC.LineTo(startPoint.X, startPoint.Y);
    end;
  end;

  // 4. Stratificări orizontale
  AC.Pen.Color := $909090; // Gri mediu
  for i := 0 to RingCount do
  begin
    y := i * (BasketHeight / RingCount);
    currentRadius := BaseRadius + (TopRadius - BaseRadius) * (y / BasketHeight);

    for j := 0 to BarCount do
    begin
      angle := 2 * Pi * j / BarCount;
      start3D := Make3D(
        BasketCenter.X + currentRadius * Cos(angle),
        BasketCenter.Y + y,
        BasketCenter.Z + currentRadius * Sin(angle) * isoScale
      );

      startPoint := ProjectIso(start3D, R);
      if j = 0 then
        AC.MoveTo(startPoint.X, startPoint.Y)
      else
        AC.LineTo(startPoint.X, startPoint.Y);
    end;
  end;

  // 5. Raze bază
  AC.Pen.Color := $00A5FF; // Albastru deschis
  AC.Pen.Width := 2;
  centerPoint := ProjectIso(BasketCenter, R);
  for j := 0 to BarCount - 1 do
  begin
    angle := 2 * Pi * j / BarCount;
    start3D := Make3D(
      BasketCenter.X + BaseRadius * Cos(angle),
      BasketCenter.Y,
      BasketCenter.Z + BaseRadius * Sin(angle) * isoScale
    );

    startPoint := ProjectIso(start3D, R);
    AC.MoveTo(centerPoint.X, centerPoint.Y);
    AC.LineTo(startPoint.X, startPoint.Y);
  end;

  // 6. Contur superior
  AC.Pen.Color := clWhite;
  AC.Pen.Width := 2;
  y := BasketHeight;
  currentRadius := TopRadius;
  for j := 0 to BarCount do
  begin
    angle := 2 * Pi * j / BarCount;
    start3D := Make3D(
      BasketCenter.X + currentRadius * Cos(angle),
      BasketCenter.Y + y,
      BasketCenter.Z + currentRadius * Sin(angle) * isoScale
    );

    startPoint := ProjectIso(start3D, R);
    if j = 0 then
      AC.MoveTo(startPoint.X, startPoint.Y)
    else
      AC.LineTo(startPoint.X, startPoint.Y);
  end;
end;



//====================================
// Desenare mingi de tenis
//====================================

procedure TForm6.DrawTennisBalls(AC: TCanvas; const R: TRect);
const
  BALL_RADIUS = 13; // Dimensiune vizibilă
var
  i: Integer;
  BallPos3D: array[0..4] of TPoint3D;
  ScreenPos: TPoint;
begin
  // Păstrăm formația generală, dar le deplasăm mai departe de braț
  // Brațul este la (220, 0, -150), le mutăm mai spre stânga (X mai mic)

  // Aranjare în formație circulară, mai departe de braț
  BallPos3D[0] := Make3D(100, 5, -35);    // Centru - mai departe de braț
  BallPos3D[1] := Make3D(135, 5, -55);    // Dreapta-față - mai departe
  BallPos3D[2] := Make3D(65, 5, -55);     // Stânga-față - mai departe
  BallPos3D[3] := Make3D(130, 5, -15);    // Dreapta-spate - mai departe
  BallPos3D[4] := Make3D(70, 5, -15);     // Stânga-spate - mai departe

  // Desenăm mingile folosind proiecția izometrică pentru a le plasa corect
  AC.Pen.Width := 2;

  for i := 0 to 4 do
  begin
    // Proiectăm poziția 3D pe ecran
    ScreenPos := ProjectIso(BallPos3D[i], R);

    // Mingea de tenis - galben intens pentru vizibilitate
    AC.Brush.Color := clYellow; // Galben intens (BGR)
    AC.Pen.Color := clBlack;
    AC.Ellipse(
      ScreenPos.X - BALL_RADIUS,
      ScreenPos.Y - BALL_RADIUS,
      ScreenPos.X + BALL_RADIUS,
      ScreenPos.Y + BALL_RADIUS
    );

    // Detaliile caracteristice mingilor de tenis
    AC.Pen.Color := clWhite;
    AC.Pen.Width := 2;
    // Linia curbată
    AC.Arc(
      ScreenPos.X - BALL_RADIUS + 4,
      ScreenPos.Y - BALL_RADIUS + 4,
      ScreenPos.X + BALL_RADIUS - 4,
      ScreenPos.Y + BALL_RADIUS - 4,
      ScreenPos.X + BALL_RADIUS,
      ScreenPos.Y,
      ScreenPos.X - BALL_RADIUS,
      ScreenPos.Y
    );
  end;
end;


//=======v==============================
// OnCreate și Timer
//=====================================

procedure TForm6.FormCreate(Sender: TObject);
var
 i: Integer;
begin
  BorderStyle := bsNone;
  WindowState := wsMaximized;
  Image1.Align := alClient;
  Image1.Stretch := True;
  cloudOffset := 0;

  // Setăm bitmap-ul de la Image1 la 32-bit pentru suportul stelelor și al gradientului
  Image1.Picture.Bitmap := TBitmap.Create;
  Image1.Picture.Bitmap.PixelFormat := pf32bit;
  Image1.Picture.Bitmap.SetSize(Image1.Width, Image1.Height);

  // Pornim soarele la răsărit
  FTimeAngle := -Pi/2;

  // Inițializare braț robotic
  for i := 0 to High(RobotJoints) do
  begin
    RobotJoints[i].Length := JointLengths[i];
    RobotJoints[i].Theta := 0;         // unghiul inițial
  end;

  // MODIFICARE IMPORTANTĂ: Inițializare poziții mingi
  // Setăm Y = 10.0 pentru a ridica mingile deasupra solului și a le face vizibile
  SetLength(BallTargets, 5);
BallTargets[0] := Make3D(120, 30.0, -80);   // Partea dreaptă
BallTargets[1] := Make3D(-100, 30.0, 40);   // Partea stângă
BallTargets[2] := Make3D(0, 30.0, -30);     // Centru
BallTargets[3] := Make3D(180, 30.0, -120);  // Lângă robot
BallTargets[4] := Make3D(-60, 30.0, 90);    // Lângă gard

  // VERIFICARE: Dacă lista de mingi este goală, adăugăm mingi de test
if Length(BallTargets) = 0 then
begin
  SetLength(BallTargets, 3);
  BallTargets[0] := Make3D(0, 50.0, 0);     // Minge în centrul terenului
  BallTargets[1] := Make3D(100, 50.0, 0);   // Minge în dreapta
  BallTargets[2] := Make3D(-100, 50.0, 0);  // Minge în stânga
end;

  // Asigură-te că robotul este inițializat corect
  RobotBase := Make3D(220, 0, -150);
  NextBallIdx := 0;

  // Generare stele
  SetLength(FStars, StarCount);
  for i := 0 to StarCount-1 do
  begin
    FStars[i].X := Random;
    FStars[i].Y := Random;
  end;

  // Timer-ul desenează cadrul scenei la fiecare interval
  Timer1.Interval := 50;
  Timer1.Enabled := True;

  // Activăm double buffering pentru eliminarea pâlpâirii
  DoubleBuffered := True;
end;

procedure TForm6.Timer1Timer(Sender: TObject);
var
  Bmp: TBitmap;
  R: TRect;
  EndEffector3D: TPoint3D;
begin
  RandSeed := 12345;
  cloudOffset := (cloudOffset + 1) mod ClientWidth;

  // Actualizăm unghiul soarelui
  FTimeAngle := FTimeAngle + 0.005;
  if FTimeAngle > 3*Pi/2 then
    FTimeAngle := -Pi/2 + (FTimeAngle - 3*Pi/2);

  // Creăm bitmap temporar pentru redibuire
  Bmp := TBitmap.Create;
  try
    Bmp.PixelFormat := pf32bit;
    Bmp.SetSize(Image1.Width, Image1.Height);
    R := Rect(0, 0, Bmp.Width, Bmp.Height);

    // === ORDINEA DESENĂRII ESTE CRITICĂ ===
    // 1) Elementele de fundal
    DrawGradientSky(Bmp.Canvas, R);
    if Sin(FTimeAngle) < 0 then
      DrawMoon(Bmp.Canvas, R);
    DrawMovingSun(Bmp.Canvas, R);
    DrawClouds(Bmp.Canvas, R, cloudOffset);
    DrawMountains(Bmp.Canvas, R);
    DrawGround(Bmp.Canvas, R);

    // 2) Terenul de tenis și mingile
    // IMPORTANT: Mingile trebuie desenate după teren și înainte de orice poate să le acopere
    DrawCourt(Bmp.Canvas, R);
    DrawNet(Bmp.Canvas, R);


    // 3) Elementele care pot acoperi mingile
    DrawBallBasket(Bmp.Canvas, R);
    DrawFence(Bmp.Canvas, R);
    DrawBanner(Bmp.Canvas, R);
    DrawLightPoles(Bmp.Canvas, R);
    DrawUmpireChair(Bmp.Canvas, R);
    DrawRoboticArm(Bmp.Canvas, R);
    DrawTree(Bmp.Canvas, R);
    DrawTennisBalls(Bmp.Canvas, R);
    // 4) Logica de prindere a mingii, după desen
    EndEffector3D := FK(RobotJoints, RobotBase);
    if (Length(BallTargets) > 0) and
       (Distance3D(EndEffector3D, BallTargets[NextBallIdx]) < 5) then
    begin
      RemoveBallAt(NextBallIdx);
      if NextBallIdx >= Length(BallTargets) then
        NextBallIdx := 0;
    end;

    // Afișăm bitmap-ul final
    Image1.Picture.Bitmap.Assign(Bmp);
    Image1.Invalidate;
  finally
    Bmp.Free;
  end;

end;
end.